\documentclass[12pt]{article}
\usepackage{charter} % font
\usepackage[margin=1in]{geometry} % margin
\usepackage{varioref} % "on the next page" label decoration
\usepackage{hyperref} % hyperlinks
\usepackage{enumitem} % Enumeration
\usepackage{float} % table placement

\usepackage[lined,dotocloa]{algorithm2e} % Pseudocode
\labelformat{algocf}{\textit{alg.}\,(#1)}

\def\code#1{\texttt{#1}} % code monospace formatting

% Questions
\newenvironment{QandA}{\begin{enumerate}[label=\bfseries\alph*.]\bfseries}
{\end{enumerate}}
\newenvironment{answered}{\par\normalfont}{}
\usepackage{lipsum}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{%
	\textbf{Assignment 6 \\ 
		Huffman Coding \\
\large DESIGN DOCUMENT} }
\author{Zack Traczyk \\ CSE13S - Spring 2021}
\date{Due: May 23\textsuperscript{th} at 11:59 pm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Objective}

Implement static lossless file compression using Huffman encoding.

\section{Given}

\begin{itemize}
	\item{Header files for definitions, header, node, priority queue, code, io, stack, Huffman}
	\item{C file for entropy}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Structures}

This assignment required a couple implementing three different datatypes to work:
nodes, a stack, and a priority queue. The implementation for these abstract
datatypes will be described in detail below.

\subsection{Nodes}

Nodes are implemented in \code{node.c} and follow the assignment document specifications.
As given in the document, a node is a structure that holds pointers to its left and 
right child, an 8-bit unsigned integer for its symbol, and a 64-bit unsigned integer 
for its frequency. Nodes are used to construct a Huffman tree which is required for
encoding.

Nodes are used to create a tree and as such require a couple of functions
to interface with them:

\begin{itemize}
	\item{\code{node\_create}: creates a node given a symbol and frequecy. Sets the left and 
		right children to \code{NULL}.}
	\item{\code{node\_delete}: deletes a node by freeing allocated memory and setting its 
		pointer to \code{NULL}.}
	\item{\code{node\_join}: joins to nodes given their pointers under a parent node with a 
			symbol of '\$' and a frequency equal to the childrens the sum of the 
		left and right frequencies.}
	\item{\code{node\_print}: this function is not utilized during encoding or decoding
		but is helpful for debugging}

\end{itemize}

This functions are all only a few lines, and therefore are trivial to implement
given the explanations above.

\subsection{Stack}

Stacks are implemented in \code{stack.c}. A stack is a structure that contains an
array of pointers to Nodes (the elements the stack holds), an unsigned 32-bit integer
to the next empty value in the stack, and an unsigned 32-bit integer that stores the
total number of nodes that can be stored.

A stack can be popped from and push to, and its size can be tested. Therefore the 
following functions are implemented for a stack:

\begin{itemize}
	\item{\code{stack\_create}: creates a stack given its capacity (how many elements it can
		hold).}
	\item{\code{stack\_delete}: deletes a stack by freeing allocated memory and setting its 
		pointer to \code{NULL}.}
	\item{\code{stack\_empty}: since a stack keeps track of the top element to know where to
		push/pop a value, a stack is therefore empty when the \code{top} is 0}
	\item{\code{stack\_full}: a stack is then full when the \code{top} is equal to the capacity}
	\item{\code{stack\_size}: since new Nodes are inserted from \code{top}, the stack size
		is equal to \code{top}.}
	\item{\code{stack\_push}: to push a new element, there must first be room. This is checked
			by calling \code{stack\_full} and returning false if \code{stack\_full} returns true.
			If there is room in the stack, the item is added at index \code{top} and \code{top} is
		then incremented.}
	\item{\code{stack\_pop}: when elements are popped the stack checks first if there is
			anything to pop using \code{stack\_empty}. If there are elements, \code{top} is
			decremented and the pointer to a Node at the now decremented \code{top} is passed
		to a Node pointer given as a parameter.} 
	\item{\code{stack\_print}: this function is not utilized during encoding or decoding
		but is helpful for debugging}
\end{itemize}

\subsection{Priority Queue}

A priority queues is implemented in \code{pq.c} using a min heap. A priority queue
is a structure that contains an array of pointers to Nodes (this is where elements
that are enqueued and dequeued are stored), an unsigned 32-bit integer to the next
empty value in the min heap, and an unsigned 32-bit integer that stores the total
capacity of the queue.

\begin{itemize}
	\item{\code{pq\_create}: creates a priority queue given its capacity (how many elements it can
		hold).}
	\item{\code{pq\_delete}: deletes a pq by freeing allocated memory and setting its 
		pointer to \code{NULL}.}
	\item{\code{pq\_node\_frequency}: this is a helper function to help with enqueuing
			and dequeuing, it is not publicly accessible. All this function does is given a pointer
			to a priority queue and an index, it calls \code{node\_frequency} on that Node and returns
		the value.}
	\item{\code{pq\_empty}: a priority queue is similar to the \code{Stack} datatype and is
		therefore empty when the \code{top} is 0}
	\item{\code{pq\_full}: a priority queue is then full when the \code{top} is equal to the capacity}
	\item{\code{pq\_size}: the priority queue size is equal to \code{top}.}
	\item{\code{enqueue} }
	\item{\code{dequeue} }
	\item{\code{pq\_print}: this function is not utilized during encoding or decoding
		but is helpful for debugging}
\end{itemize}

\subsection{Codes}

Huffman compression works by assigning codes to symbols where the most used symbols have the
shortest codes. These codes are implemented using a structure containing an unsigned 32 bit
integer to track the top of the code, and an array of unisgned 8 bit integers to store the
bits in the code like a stack. Since elements in a code are bits stored inside array elements, \code{top}
tracks the top bit not the top index. Codes are constructed by traversing the tree left = 0 and right = 1 until
a leaf is found at which the order of lefts and rights, 1s and 0s is the code. This is explained
further in subsection \vref{huffman}. However, this functionality dictates that a code
needs to be able to pop and push bits as well as check the size.

The following functions are implemented in \code{code.c}:

\begin{itemize}
	\item{\code{code\_create}: creates a code and initializes it to 0.
			The code structure is defined globally so its members can be accessed. The size
		of a code is constant so there is no need to allocate space at runtime}
	\item{\code{code\_delete}: deletes a code by freeing allocated memory and setting its 
		pointer to \code{NULL}.}
	\item{\code{code\_empty}: since a code keeps track of the top element to know where to push/pop
		a value, a stack is therefore empty when the \code{top} is 0}
	\item{\code{code\_full}: a code is then full when the $\code{top} / 8$ is equal to the
		capacity (\code{MAX\_CODE\_SIZE})}
	\item{\code{code\_size}: the code size is equal to \code{top}.}
	\item{\code{code\_push}: to push a new element, there must first be room. This is checked
			by calling \code{code\_full} and returning false if \code{code\_full} returns true.
			If there is room in the stack, the new bit is inserted in the array at the $\code{top} / 8$ element
		at the $\code{top} \% 8$bit.}
	\item{\code{code\_pop}: when elements are popped the stack checks first if there is
			anything to pop using \code{code\_empty}. If there are elements, \code{top} is
			decremented and the pointer to a bit at the now decremented \code{top} is passed
		to a Node pointer given as a parameter.} 
	\item{\code{code\_print}: this function is not utilized during encoding or decoding
		but is helpful for debugging}
\end{itemize}

\section{Programs}

Before creating the two required programs, encode and decode, some more helpful
functions needed to be implemented to help with io functionality and to assist
with the encoding and decoding.

\subsection{IO}

Two global variables are defined in \code{io.c}: \code{bytes\_read} and \code{bytes\_written}.
These variables track how many times bytes have been read and written to/ from a file.
Additionally, io needs to be handled for six main functions: reading bytes, writing bytes,
reading the header, writing the header, reading a bit, and writing codes.

Reading and writing bytes and the header are almost identical. In \vref{read_main} read
functionality is shown but write functionality is identical and header reading and writing
only requires the size of the read/write call to be equal to the size of the \code{Header}
structure.

\begin{algorithm}
	bytes read = 0\;
	last bytes read = 0\;

	\While{(bytes read += read(from infile to buffer for nbytes) is less than bytes to read}{
		\If{last read is equal to bytes read}{
			Break\;
		}
		last bytes read = bytes read\;
	}

	global bytes read += bytes read\;
	\Return{bytes read}
	\caption{Basic Reading}\label{read_main}
\end{algorithm}



\subsection{Huffman Trees}\label{huffman}

Huffman trees utilize a few different functions when encoding or decoding. These functions
mainly deal with constructing, deleteing, reconstructing, and traversing Huffman trees.

\subsection{Encode}

\begin{itemize}
	\item{-h : Command line options}
	\item{-i \code{infile} : The file containing bytes to be encoded (default is \code{stdin})}
	\item{-o \code{outfile} : The output file to store encoded bytes (default is \code{stdout})}
	\item{-v : Prints compression statists of the encoding process to \code{stderr}}
\end{itemize}

\subsection{Decode}

\begin{itemize}
	\item{-h : Command line options }
	\item{-i \code{infile} : The file containing bytes to be decoded (default is \code{stdin})}
	\item{-o \code{outfile} : The output file to store decoded bytes (default is \code{stdout})}
	\item{-v : Prints statists of the decoding process to \code{stderr}}
\end{itemize}

\subsection{Entropy}

The source code for this program (\code{entropy.c}) is provided in the class resources repository.
Entropy calculates the entropy, or variation of contents, for a file.

\section{Parse}

Program arguments are parsed and stored using flags.
A set is not used since the order of the inputs is irrelevant and the parsed data
will ultimately be stored in variables anyway.

After program arguments are parsed the input file is parsed with encode or decode.
Execution happens with every grab of a byte to the buffer.
Refer to execute for how the algorithm works.

\section{Execute}

\subsection{Encode}

First, the infile is checked to see if it is seekable. Since Huffman encoding
requires two passes, the file must be read twice. This is impossible for piped input,
therefore a tempfile is made whenever the input is unseekable. Compressing a file 
requires a few steps. First, a histogram is constructed of the
most used characters. If a tempfile has been initalized, then the parsed characters
and then written to the tempfile to be read on the second pass. Once each character
has a frequency, the histogram elements
are converted to nodes and enqueued into a priority queue. Then, two nodes are 
popped off at at time and joined together and queued back into the priority
queue until only one node remains. This last node is the root to the Huffman
tree. Finally the Huffman coding happens as the tree is traversed and codes
are assigned to all the characters. This pseudocode for this procedure
can be seen in \vref{encode}.

\begin{algorithm}
	\If{not seekable}{
		create tempfile\;
	}
	call fstat on infile and assign to statbuf\;
	\If{filein is not stdin and fileout is not stdout}{
		modify permissions of outfile to match infile\;
	}

	initalize a histogram of length ALPHABET\;
	histogram at 0 is 1\;
	histogram at 255 is 1\;
	initalize read buffer\;

	\While{length from read\_bytes(read from filein to buffer with size of BLOCK)
		is greater than 0}{
		\If{tempfile exists}{
			write\_bytes(wrte to filout from buffer for BLOCK bytes)\;
		}
		\For{every read byte in buffer}{
			increment corresponding histogram array element to buffer charater\;
		}
	}

	root of Huffman tree = build\_tree(from histogram)\;
	create a header and write to fileout\;	
	initalize a table with empty codes\;
	build\_codes(root, from table)\;
	write the tree to outfile\;

	\If{tempfile used}{
		set filein to tempfile\;
	}

	\While{length from read\_bytes(read from filein to buffer with size of BLOCK)
		is greater than 0}{
		\For{every read byte in buffer}{
			write\_code(fileout, from code table of the current character)\;
		}
	}

	print statistics if verbose\;
	close files and free allocated space\;

	\caption{Encode}\label{encode}
\end{algorithm}

\subsection{Decode}

Decode is (unsurprisingly) the opposite of encode. Codes are read from the file
and decoded.

\begin{algorithm}
	\caption{Decode}\label{decode}
\end{algorithm}

\end{document}
