\documentclass[12pt]{article}
\usepackage{charter} % font
\usepackage[margin=1in]{geometry} % margin
\usepackage{varioref} % "on the next page" label decoration
\usepackage{hyperref} % hyperlinks
\usepackage{enumitem} % Enumeration
\usepackage{float} % table placement

\usepackage[lined,dotocloa]{algorithm2e} % Pseudocode
\labelformat{algocf}{\textit{alg.}\,(#1)}

\def\code#1{\texttt{#1}} % code monospace formatting

% Questions
\newenvironment{QandA}{\begin{enumerate}[label=\bfseries\alph*.]\bfseries}
{\end{enumerate}}
\newenvironment{answered}{\par\normalfont}{}
\usepackage{lipsum}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{%
    \textbf{Assignment 6 \\ 
        Huffman Coding \\
\large DESIGN DOCUMENT} }
\author{Zack Traczyk \\ CSE13S - Spring 2021}
\date{Due: May 23\textsuperscript{th} at 11:59 pm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\section{Objective}

Implement static lossless file compression using Huffman encoding.

\section{Given}

\begin{itemize}
    \item{Header files for definitions, header, node, priority queue, code, io, stack, Huffman}
	\item{C file for entropy}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Structures}

This assignment required a couple implementing three different datatypes to work:
nodes, a stack, and a priority queue. The implementation for these abstract
datatypes will be described in detail below.

\subsection{Nodes}

Nodes are implemented in \code{node.c} and follow the assignment document specifications.
As given in the document, a node is a structure that holds pointers to its left and 
right child, an 8-bit unsigned integer for its symbol, and a 64-bit unsigned integer 
for its frequency. Nodes are used to construct a Huffman tree which is required for
encoding.

\subsection{Stack}

Stacks are implemented in \code{stack.c}. A stack is a structure that contains an
array of pointers to Nodes (the elements the stack holds), an unsigned 32-bit integer
to the next empty value in the stack, and an unsigned 32-bit integer that stores the
total capacity of the queue.

\subsection{Priority Queue}

Priority queues are implemented in \code{pq.c} using a min heap. A priority queue
is a structure that contains an array of pointers to Nodes (this is where elements
that are enqueued and dequeued are stored), an unsigned 32-bit integer to the next
empty value in the stack, and an unsigned 32-bit integer that stores the total
capacity of the queue.

\section{Programs}

Before creating the two required programs, encode and decode, some more helpful
functions needed to be implemented to help with io functionality and to assist
with the encoding and decoding.

\subsection{IO}

Two global variables are defined in \code{io.c}: \code{bytes read} and \code{bytes written}.
These variables track how many times bytes have been read and written to/ from a file.
Additionally, there are four main io functions: read bytes, write bytes, read bit, write codes.

\subsection{Encode}

\begin{itemize}
    \item{-h : Command line options}
	\item{-i \code{infile} : The file containing bytes to be encoded (default is \code{stdin})}
	\item{-o \code{outfile} : The output file to store encoded bytes (default is \code{stdout})}
	\item{-v : Prints compression statists of the encoding process to \code{stderr}}
\end{itemize}

\subsection{Decode}

\begin{itemize}
    \item{-h : Command line options }
	\item{-i \code{infile} : The file containing bytes to be decoded (default is \code{stdin})}
		\item{-o \code{outfile} : The output file to store decoded bytes (default is \code{stdout})}
	\item{-v : Prints statists of the decoding process to \code{stderr}}
\end{itemize}

\subsection{Entropy}

The source code for this program (\code{entropy.c}) is provided in the class resources repository.
Entropy calculates the entropy, or variation of contents, for a file.

\section{Parse}

Program arguments are parsed and stored using flags.
A set is not used since the order of the inputs is irrelevant and the parsed data
will ultimately be stored in variables anyway.

After program arguments are parsed the input file is parsed with encode or decode.
Execution happens with every grab of a byte to the buffer.
Refer to execute for how the algorithm works.

\section{Execute}

\subsection{Encode}

Compressing a file requires a few steps. First, a histogram is constructed of the
most used characters. Once each character has a frequency, the histogram elements
are converted to nodes and enqueued into a priority queue. Then, two nodes are 
popped off at at time and joined together and queued back into the priority
queue until only one node remains. This last node is the root to the Huffman
tree. Finally the Huffman coding happens as the tree is traversed and codes
are assigned to all the characters.\vref{encode}.

\begin{algorithm}
    \caption{Encode}\label{encode}
\end{algorithm}

\subsection{Decode}

Decode is (unsurprisingly) the opposite of encode. Codes are read from the file
and decoded.
The pseduocode is shown in \vref{decode}.

\begin{algorithm}
    \caption{Decode}\label{decode}
\end{algorithm}

\end{document}
