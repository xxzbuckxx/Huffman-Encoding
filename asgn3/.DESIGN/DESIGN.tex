\documentclass[12pt]{article}
\usepackage{charter} % font
\usepackage[margin=1in]{geometry} % margin
\usepackage{varioref} % "on the next page" label decoration
\usepackage{hyperref} % hyperlinks
\usepackage{enumitem} % Enumeration

\usepackage[lined,dotocloa]{algorithm2e} % Pseudocode
\labelformat{algocf}{\textit{alg.}\,(#1)}


% Questions
\newenvironment{QandA}{\begin{enumerate}[label=\bfseries\alph*.]\bfseries}
{\end{enumerate}}
\newenvironment{answered}{\par\normalfont}{}
\usepackage{lipsum}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{%
    \textbf{Assignment 3 \\ 
    Sorting: Putting your affairs in order \\
    \large DESIGN DOCUMENT} }
    \author{Zack Traczyk \\ CSE13S - Spring 2021}
    \date{Due: April 25\textsuperscript{th} at 11:59 pm}

    \begin{document}

    \maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \section{Objective}

    The objective of this lab is to implement Bubble Sort, Shell Sort, and two Quick-sorts. In addition to these implementations a big O analysis is done.

    \section{Given}

    These code snippets are given:

    \begin{itemize}
        \item Stack implementation for Quicksort
        \item Queue implementation for Quicksort
        \item Python implementation of the algorithms (for pseudocode)

    \end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \section{Prelab Questions}

    \subsection{Bubble Sort}
    \begin{QandA}

    \item How many rounds of swapping will need to sort the numbers 8,22,7,9,31,5,13 in ascending order using Bubble Sort?
        \begin{answered}
            8, 22, 7, 9, 31, 5, 13 - original

            8, 7, 9, 22, 5, 13, 31 - round 1

            7, 8, 9, 5, 13, 22, 31 - round 2

            7, 8, 5, 9, 13, 22, 31 - round 3

            7, 5, 8, 9, 13, 22, 31 - round 4

            5, 7, 8, 9, 13, 22, 31 - Sorted

            5 Rounds of swapping
        \end{answered}

    \item How many comparisons can we expect to see in the worse Case scenario for Bubble Sort? Hint: make a list of numbers and attempt to sort them using Bubble Sort.

        \begin{answered}
			The worst Case scenario is a list in reverse order. Each round takes $n$ comparisions. Then it takes $n$ iterations to completely sort the list making the worst Case take $O(n^2)$ comparisions.
        \end{answered}
    \end{QandA}

    \subsection{Shell Sort}
    \begin{QandA}

    \item The worst time complexity for Shell Sort depends on the sequence of gaps. Investigate why this is the Case. How can you improve the time complexity of this sort by changing the gap size? Cite any sources you used.
        \begin{answered}
            test Watched \href{https://www.youtube.com/watch?v=NYWEM7H3iYc\&t=269s}{sorting visualizations}.
			Shell sort's efficiency is dependent on the gaps used to sort. Imagine an array where the 1 is at index 0, 2 is at index n, 3 is at index 1 and four is at index n - 1. If shell sort had a gap size of two then it would be as inefficeint as bubble sort.
			However, if the gap size starts at 1 less than the length of the array and decreases by 1, then the algorithm would be super efficient: \href{https://www.codesdope.com/blog/article/shell-sort/}{Codesdope}.
        \end{answered}

    \end{QandA}


    \subsection{Quick Sort}
    \begin{QandA}
    \item Quicksort, with a worse Case time complexity of $O(n^2)$, doesn’t seem to live up to its name. Investigate and explain why Quicksort isn’t doomed by its worst Case scenario. Make sure to cite any sources you use.
        \begin{answered}
            Quicksort's worst Case happens when a pivot element is picked at either the end or beginning of the array. However, this does not doom Quicksort since the pivot point is decided by the programmer. In other words, $O(N^2)$ only happens because of the programmers own fault rather than intrinsic inefficiency of the algorithm. \href{https://www.baeldung.com/cs/quicksort-time-complexity-worst-Case}{Baeldung CS}
        \end{answered}


    \end{QandA}

    \subsection{General Sorting}
    \begin{QandA}
    \item Explain how you plan on keeping track of the number of moves and comparisons since each sort will reside within its own file.
        \begin{answered}
            The number of moves and comparisons will be tracked by using analytics.h and global variables that are initialized in the test harness.
        \end{answered}


    \end{QandA}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \section{Test Harness}

	The test harness takes in a couple of arguments specifying which sorts to run and for what size and how many elements. Program arguments are first parsed and stored in a bit field. 1 = True and 0 = False, [Bubble, Shell, Quicksort1, Quicksort2]. This process can be seen in \vref{parse}.

    \begin{algorithm}
		\lIf{no program arguments}{\Return{error}}
        run\_all = False\;
		execute = 0000\tcc*[r]{bit field}
        seed = 13371453\tcc*[r]{Initialized with default seed}
        size = 100\tcc*[r]{Initialized with default size}
        elements = 100\tcc*[r]{Initialized with default number of elements}
        \While{get next argument with }{
            \Switch{opt}{
                \lCase{a}{run\_all is true}
				\lCase{b}{execute = execute bitwise or 0001}
				\lCase{s}{execute = execute bitwise or 0010}
				\lCase{q}{execute = execute bitwise or 0100}
				\lCase{Q}{execute = execute bitwise or 1000}
                \lCase{r}{seed = argument value}
                \lCase{n}{size = argument value}
                \lCase{p}{elements = argument value}
                \lCase{h}{print help message}
            }
        }
		\lIf{execute empty and run\_all is not true}{\Return{error}}

        \caption{Parse Program Arguments}\label{parse}
    \end{algorithm}

    After the program arguments are parsed, the program then either runs all or iterates through the execute array produced in the parse. This process can be seen in \vref{execute}. 
    This uses a \href{https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/}{dynamically sorted array}.

    \begin{algorithm}
		functions = \{bubble\_sort, shell\_sort, quicksort\_stack, quicksort\_heap\}\;
		\For{i from 0 to 4}{
			\If{run\_all or execute bit [i] is True}{
				functions[i](seed, size, elements)\;
			}
		}

        \caption{Execute Algorithms}\label{execute}
    \end{algorithm}

    \section{Bubble Sort}

    Bubble Sort is fairly easy to implement given the python pseudocode.

    \section{Shell Sort}

    Varation of insertion sort.
    Given a gap sequnce, the Pratt sequence (also called 3-smooth), in header file

    \section{Quick Sort}

	Quicksort is implemented using the pseudocode and the the given stack and queue implenetations.

	\subsection{Stack}

	\subsection{Queue}

\end{document}

